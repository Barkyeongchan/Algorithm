# 슬라이딩 윈도우(Sliding Window) / 그리디 알고리즘(Greedy Algorithm)

## 목차
1. 슬라이딩 윈도우(Sliding Window)
   - 슬라이딩 윈도우란?
   - 작동 원리
2. 그리디 알고리즘(Greedy Algorithm)
   - 그리디 알고리즘이란?

## 1. 슬라이딩 윈도우(Sliding Window)

### 1-1. 슬라이딩 윈도우란?

<img width="495" height="308" alt="image" src="https://github.com/user-attachments/assets/c6f718e7-447b-4ad9-bc7d-590e7f0749c8" />

배열이나 리스트 같은 데이터의 **특정 범위(윈도우)** 를 정해놓고, 이 윈도우를 특정 크기만큼 이동시켜 데이터의 특덩 패턴이나 조건을 찾는 알고리즘

이전에 계산한 결과를 재활용하거나, 불필요한 계산을 줄일 수 있어 효율적

### 1-2. 작동 원리

1. 초기 윈도우 설정
   - 데이터의 가장 앞부분에 **윈도우의 크기**만큼 영역 설정 (초기 윈도우)
   - 초기 윈도우에 해당하는 데이터를 처리 (예 : 합계 계산 등)

2. 윈도우 이동
   - 윈도우를 데이터의 다음 위치로 정해진 크기만큼 이동
   - 윈도우의 **시작점(left)**과 **끝점(right)**이 오른쪽으로 이동
  
3. 데이터 업데이트
   - 이동한 위도우에 새로 포함되는 데이터는 추가하고(right), 윈도우에서 벗어나는 데이터는 제거(left)
   - 윈도우 안의 모든 데이터를 볼 필요없이 변화한 부분만 확인하면 됨 = 효율적인 계산
  
4. 반복

```python3
def sliding_window_sum(nums, k):
    """
    슬라이딩 윈도우를 사용하여 배열의 모든 'k' 크기 부분 배열의 합을 계산합니다.

    Args:
        nums (list): 숫자로 이루어진 배열.
        k (int): 윈도우(부분 배열)의 크기.

    Returns:
        list: 각 윈도우의 합을 담은 리스트.
    """

    if k <= 0 or k > len(nums):
        # 유효하지 않은 윈도우 크기에 대한 예외 처리
        print("경고: 유효하지 않은 윈도우 크기입니다. 배열의 길이를 확인해주세요.")
        return []

    window_sums = [] # 각 윈도우의 합을 저장할 리스트

    # 1. 초기 윈도우 설정 (Window Initialization)
    # 첫 'k'개의 요소들의 합을 계산합니다.
    current_window_sum = sum(nums[0:k]) # 0부터 k-1까지의 합
    window_sums.append(current_window_sum) # 첫 윈도우의 합을 결과 리스트에 추가

    print(f"초기 윈도우 [{nums[0]}, ..., {nums[k-1]}] 합: {current_window_sum}")

    # 2. 윈도우 이동 및 3. 데이터 업데이트 (Window Slide & Update)
    # 윈도우를 오른쪽으로 한 칸씩 이동합니다.
    # right_pointer는 윈도우에 새로 들어올 요소의 인덱스를 가리킵니다.
    # 시작점(left)은 0부터 시작했으므로, right_pointer는 k부터 시작합니다.
    for right_pointer in range(k, len(nums)):
        # 새롭게 윈도우에 포함되는 데이터 추가: nums[right_pointer]
        # 윈도우 범위에서 벗어나는 데이터 제거: nums[right_pointer - k]
        # (현재 right_pointer에서 k칸 뒤에 있는 요소가 윈도우에서 나가는 요소입니다)
        current_window_sum += nums[right_pointer] - nums[right_pointer - k]

        # 현재 윈도우의 합을 결과 리스트에 추가
        window_sums.append(current_window_sum)

        # 윈도우의 현재 상태와 합을 출력 (디버깅용)
        # left_pointer는 right_pointer - k + 1 입니다.
        left_pointer = right_pointer - k + 1
        print(f"윈도우 이동: [{nums[left_pointer]}, ..., {nums[right_pointer]}] 합: {current_window_sum}")

    # 4. 반복 (Iteration)은 for 루프가 끝날 때까지 계속됩니다.

    return window_sums


# --- 예시 사용 ---
my_numbers = [1, 5, 2, 8, 3, 7, 4]
window_size = 3

print(f"\n입력 배열: {my_numbers}, 윈도우 크기: {window_size}")
result_sums = sliding_window_sum(my_numbers, window_size)
print(f"\n모든 윈도우 합: {result_sums}")

print("\n--- 다른 예시 ---")
my_numbers_2 = [10, 20, 30, 40, 50]
window_size_2 = 2
print(f"\n입력 배열: {my_numbers_2}, 윈도우 크기: {window_size_2}")
result_sums_2 = sliding_window_sum(my_numbers_2, window_size_2)
print(f"\n모든 윈도우 합: {result_sums_2}")
```
