# 슬라이딩 윈도우(Sliding Window) / 그리디 알고리즘(Greedy Algorithm)

## 목차
1. 슬라이딩 윈도우(Sliding Window)
   - 슬라이딩 윈도우란?
   - 작동 원리
2. 그리디 알고리즘(Greedy Algorithm)
   - 그리디 알고리즘이란?

## 1. 슬라이딩 윈도우(Sliding Window)

### 1-1. 슬라이딩 윈도우란?

<img width="495" height="308" alt="image" src="https://github.com/user-attachments/assets/c6f718e7-447b-4ad9-bc7d-590e7f0749c8" />

배열이나 리스트 같은 데이터의 **특정 범위(윈도우)** 를 정해놓고, 이 윈도우를 특정 크기만큼 이동시켜 데이터의 특덩 패턴이나 조건을 찾는 알고리즘

이전에 계산한 결과를 재활용하거나, 불필요한 계산을 줄일 수 있어 효율적

### 1-2. 작동 원리

1. 초기 윈도우 설정
   - 데이터의 가장 앞부분에 **윈도우의 크기**만큼 영역 설정 (초기 윈도우)
   - 초기 윈도우에 해당하는 데이터를 처리 (예 : 합계 계산 등)

2. 윈도우 이동
   - 윈도우를 데이터의 다음 위치로 정해진 크기만큼 이동
   - 윈도우의 **시작점(left)**과 **끝점(right)**이 오른쪽으로 이동
  
3. 데이터 업데이트
   - 이동한 위도우에 새로 포함되는 데이터는 추가하고(right), 윈도우에서 벗어나는 데이터는 제거(left)
   - 윈도우 안의 모든 데이터를 볼 필요없이 변화한 부분만 확인하면 됨 = 효율적인 계산
  
4. 반복

```python3
'''
배열 nums가 주어졌을 때, 크기가 k인 슬라이딩 윈도우를 오른쪽 끝까지 이동시키며 각 윈도우의 합을 구하라.

[입력]
nums = [1, 2, 3, 4, 5]
k = 3

[출력]
[6, 9, 12]
'''

nums = [1, 2, 3, 4, 5]
k = 3

# 첫 번째 윈도우는 nums[0] + nums[1] + nums[2] = 1 + 2 + 3 = 6
window_sum = sum(nums[:k])
print(window_sum)  # 출력: 6

for i in range(k, len(nums)):
    # i는 현재 새로 들어올 값의 인덱스
    # nums[i]는 새로 들어온 값
    # nums[i - k]는 왼쪽 끝에서 빠져나가는 값
    
    # 예: i=3이면 nums[3]=4 들어오고, nums[0]=1 나감 → 6 + 4 - 1 = 9
    window_sum += nums[i] - nums[i - k]
    
    # 현재 윈도우의 합을 출력
    print(window_sum)
```



### 1-3. 투 포인터(Two Pointer)와의 차이점

<img width="405" height="250" alt="image" src="https://github.com/user-attachments/assets/e9c8fe71-4915-4f3b-9544-cd0526919791" />


| 항목             | 슬라이딩 윈도우 (Sliding Window)               | 투 포인터 (Two Pointers)                       |
|------------------|------------------------------------------------|------------------------------------------------|
| 기본 개념         | 고정 또는 가변 길이의 윈도우를 오른쪽으로 이동시키며 탐색 | 두 개의 포인터를 사용하여 배열을 탐색         |
| 주요 목적         | 연속된 범위에서 최적값(최대/최소/합 등) 구하기   | 두 위치 간의 관계나 조건을 만족하는 쌍/구간 찾기 |
| 사용 예시         | 부분합, 최대/최소 길이 부분 배열 등              | 정렬된 배열에서 합이 특정값이 되는 쌍 찾기 등     |
| 윈도우 크기       | 일반적으로 일정하거나 조건에 따라 조절됨         | 윈도우의 개념 없이 포인터 위치만 이동             |
| 전제 조건         | 주로 연속된 구간 처리에 적합                     | 정렬된 배열이거나, 특정 조건에 따라 포인터 이동 가능 |
| 구현 방식         | 하나의 포인터(또는 인덱스)로 시작해서 구간 유지  | 두 포인터가 각각 독립적으로 움직임               |
| 시간 복잡도 최적화 | O(N)으로 최적화 가능                            | O(N), O(N^2) 등 문제에 따라 다름                 |
| 직관성            | 특정 길이의 구간을 처리할 때 직관적              | 조건 만족 여부에 따라 포인터를 조절해야 하므로 비교적 복잡 |


