# 슬라이딩 윈도우(Sliding Window) / 그리디 알고리즘(Greedy Algorithm)

## 목차
1. 슬라이딩 윈도우(Sliding Window)
   - 슬라이딩 윈도우란?
   - 작동 원리
2. 그리디 알고리즘(Greedy Algorithm)
   - 그리디 알고리즘이란?

## 1. 슬라이딩 윈도우(Sliding Window)

### 1-1. 슬라이딩 윈도우란?

<img width="495" height="308" alt="image" src="https://github.com/user-attachments/assets/c6f718e7-447b-4ad9-bc7d-590e7f0749c8" />

배열이나 리스트 같은 데이터의 **특정 범위(윈도우)** 를 정해놓고, 이 윈도우를 특정 크기만큼 이동시켜 데이터의 특덩 패턴이나 조건을 찾는 알고리즘

이전에 계산한 결과를 재활용하거나, 불필요한 계산을 줄일 수 있어 효율적

### 1-2. 작동 원리

1. 초기 윈도우 설정
   - 데이터의 가장 앞부분에 **윈도우의 크기**만큼 영역 설정 (초기 윈도우)
   - 초기 윈도우에 해당하는 데이터를 처리 (예 : 합계 계산 등)

2. 윈도우 이동
   - 윈도우를 데이터의 다음 위치로 정해진 크기만큼 이동
   - 윈도우의 **시작점(left)**과 **끝점(right)**이 오른쪽으로 이동
  
3. 데이터 업데이트
   - 이동한 위도우에 새로 포함되는 데이터는 추가하고(right), 윈도우에서 벗어나는 데이터는 제거(left)
   - 윈도우 안의 모든 데이터를 볼 필요없이 변화한 부분만 확인하면 됨 = 효율적인 계산
  
4. 반복

```python3
'''
예제 코드

배열 nums가 주어졌을 때, 크기가 k인 슬라이딩 윈도우를 오른쪽 끝까지 이동시키며 각 윈도우의 합을 구하라.

[입력]
nums = [1, 2, 3, 4, 5]
k = 3

[출력]
6
9
12
'''

nums = [1, 2, 3, 4, 5]
k = 3

window_sum = sum(nums[:k])   # 첫 번째 윈도우는 nums[0] + nums[1] + nums[2] = 1 + 2 + 3 = 6
print(window_sum)            # 출력: 6

for i in range(k, len(nums)):   # == range(3, 5) == 3이상, 5미만 == 3과 4
    # i는 현재 새로 들어올 값의 인덱스
    
    window_sum += nums[i] - nums[i - k]   # nums[i]는 새로 들어온 값, nums[i - k]는 왼쪽 끝에서 빠져나가는 값
     # i=3이면 nums[3]=4 들어오고, nums[0]=1 나감 → 6 + 4 - 1 = 9
     # i=4이면 nums[4]=5 들어오고, nums[1]=2 나감 → 9 + 5 - 2 = 12

    print(window_sum)    # 현재 윈도우의 합을 출력
```

### 1-3. 투 포인터(Two Pointer)와의 차이점

<img width="405" height="250" alt="image" src="https://github.com/user-attachments/assets/e9c8fe71-4915-4f3b-9544-cd0526919791" />


| 항목             | 슬라이딩 윈도우 (Sliding Window)               | 투 포인터 (Two Pointers)                       |
|------------------|------------------------------------------------|------------------------------------------------|
| 기본 개념         | 고정 또는 가변 길이의 윈도우를 오른쪽으로 이동시키며 탐색 | 두 개의 포인터를 사용하여 배열을 탐색         |
| 주요 목적         | 연속된 범위에서 최적값(최대/최소/합 등) 구하기   | 두 위치 간의 관계나 조건을 만족하는 쌍/구간 찾기 |
| 사용 예시         | 부분합, 최대/최소 길이 부분 배열 등              | 정렬된 배열에서 합이 특정값이 되는 쌍 찾기 등     |
| 윈도우 크기       | 일반적으로 일정하거나 조건에 따라 조절됨         | 윈도우의 개념 없이 포인터 위치만 이동             |
| 전제 조건         | 주로 연속된 구간 처리에 적합                     | 정렬된 배열이거나, 특정 조건에 따라 포인터 이동 가능 |
| 구현 방식         | 하나의 포인터(또는 인덱스)로 시작해서 구간 유지  | 두 포인터가 각각 독립적으로 움직임               |
| 시간 복잡도 최적화 | O(N)으로 최적화 가능                            | O(N), O(N^2) 등 문제에 따라 다름                 |
| 직관성            | 특정 길이의 구간을 처리할 때 직관적              | 조건 만족 여부에 따라 포인터를 조절해야 하므로 비교적 복잡 |

### 1-4. 예제 코드

```python3
# 배열 nums가 주어졌을 때 k 크기의 슬라이딩 윈도우를 오른쪽 끝까지 이동하면서 최대 슬라이딩 윈도우를 구하라.
# 
# [입력]
# nums = [1,3,-1,-3,5,3,6,7], k = 3
# 
# [출력]
# [3,3,5,5,6,7]

s = Solution()
nums = [1,3,-1,-3,5,3,6,7]
k = 3

# 1. 브루트 포트(Brute Force)로 계산 = 가능한 모든 경우를 다 시도해 정답을 찾는 방법
from typing import List

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if not nums:   # 입력 리스트가 비어있으면 그대로 반환
            return nums
        
        r = []   # 결과를 저장할 리스트

        # 윈도우가 nums를 벗어나지 않도록 마지막 시작 인덱스 (len(nums)-k)에서 끝 숫자를 포함 시키기 위해 +1
        for i in range(len(nums) - k + 1):
            r.append(max(nums[i:i + k]))     # 현재 윈도우 구간 nums[i:i+k]에서 최대값을 찾아서 결과 리스트에 추가
            
        return r  # 모든 윈도우의 최대값 리스트 반환

print(s.maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]


# 2. 큐(Queue)를 이용한 최적화 = 선입선출(First In First Out)의 구조
from typing import List
import collections

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        results = []                    # 결과를 저장할 리스트
        window = collections.deque()    # 현재 윈도우 값들을 저장하는 덱 (양쪽에서 빠르게 삽입/삭제 가능)
        current_max = float('-inf')     # 현재 윈도우의 최댓값 초기화 (아주 작은 값)
                                        # -inf == 음의 무한대 / float('-inf') == 아주 작은 실수 값(통상적으로 사용)

        for i, v in enumerate(nums):    # nums 배열을 인덱스 i와 값 v로 순회
            window.append(v)            # 현재 값 v를 윈도우(덱)에 추가
            
            if i < k - 1:               # 윈도우 크기 k가 채워지기 전까지는 결과를 계산하지 않고 다음으로 이동
                continue
            
            # 윈도우가 처음 채워지는 시점이나 최댓값이 초기화 상태일 때
            if current_max == float('-inf'):
                current_max = max(window)  # 현재 윈도우에서 최댓값을 구함
            
            # 새로 들어온 값 v가 기존 최댓값보다 크면 최댓값 갱신
            elif v > current_max:
                current_max = v
                
            results.append(current_max)  # 현재 윈도우 최댓값을 결과에 추가
            
            # 윈도우에서 가장 오래된 값이 최댓값이라면 윈도우에서 제거 후 최댓값 초기화
            if current_max == window.popleft():
                current_max = float('-inf')
        
        return results                  # 모든 윈도우 최댓값 리스트 반환

print(s.maxSlidingWindow(nums, k))   # [3, 3, 5, 5, 6, 7]
```
