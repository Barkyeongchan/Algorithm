# 정렬

## 목차
1. 정렬의 종류
2. 이진 검색
3. 예제 코드
4. 개인 프로젝트

## 1. 정렬의 종류

### 1-1. 선택 정렬 (Selection Sort)

가장 작은 값을 선택해 맨 앞과 교환 / O(n2)
 
단순하지만 느린 속도
```python3
def selection_sort(a):
    n = len(a)  # 리스트 길이 저장

    for i in range(n):
        min_idx = i  # 현재 위치의 인덱스를 최소값 위치라고 가정

        # 나머지 요소들과 비교해서 더 작은 값이 있으면 위치를 기억함
        for j in range(i+1, n):
            if a[j] < a[min_idx]:
                min_idx = j

        # 가장 작은 값과 현재 위치의 값을 바꿈
        a[i], a[min_idx] = a[min_idx], a[i]

    return a

print(selection_sort([5, 3, 8, 4, 2]))
# 출력: [2, 3, 4, 5, 8]
```

### 1-2. 버블 정렬 (Bubble Sort)

인접한 두 값을 비교하여 큰 값을 뒤로 보냄 / O(n2)

단순하지만 느린 속도
```python3
def bubble_sort(a):
    n = len(a)

    # 리스트를 n번 반복함 (모든 요소가 정렬될 때까지)
    for i in range(n):    # 리스트의 앞에서부터 인접한 값끼리 비교함
        for j in range(0, n - i - 1):    # 뒤쪽은 이미 정렬됐으므로 비교할 범위를 점점 줄임
            if a[j] > a[j + 1]:     # 앞의 값이 뒤의 값보다 크면 자리를 바꿈 (오름차순)
                a[j], a[j + 1] = a[j + 1], a[j]  # 스왑

    return a

print(bubble_sort([5, 3, 8, 4, 2]))
# 출력: [2, 3, 4, 5, 8]
```

### 1-3. 삽입 정렬 (Insertion Sort)

앞에서부터 하나씩 꺼내어 자기 위치에 삽입 / O(n2)

정렬이 어느정도 진행된 데이터에 적용시 빠른 속도
```python3
def insertion_sort(a):
    n = len(a)
    # 1번째 인덱스부터 시작해서 오른쪽으로 이동하면서 정렬
    for i in range(1, n):
        key = a[i]  # 현재 정렬할 값 저장
        j = i - 1     # key보다 앞쪽 요소들의 인덱스

        # 왼쪽 값이 key보다 크면 한 칸 오른쪽으로 이동
        while j >= 0 and a[j] > key:
            a[j + 1] = a[j]  # 큰 값을 오른쪽으로 밀기
            j -= 1

        # key가 들어갈 자리를 찾았으므로 삽입
        a[j + 1] = key

    return a

# 예시
print(insertion_sort([5, 3, 8, 4, 2]))
# 출력: [2, 3, 4, 5, 8]
```

### 1-4. 병합 정렬 (Merge Sort)

리스트를 반으로 나눈 뒤 정렬하여 합침 / O(n log n)

안정 정렬
> 안정 정렬과 불안정 정렬
> 같은 값을 가진 데이터의 순서가 정렬 한 후 바뀔 수 있는지에 따라
> 안정 정렬(안바뀜)과 불안정 정렬(바뀜)으로 구분함
> > <img width="562" height="362" alt="image" src="https://github.com/user-attachments/assets/985aa9f1-8f9b-4885-aa07-d852d152511e" />

분할정복
>큰 문제를 분할(**Divide**)하여 작은 문제로 만들어 해결(**Conquer**)하여 결과를 합쳐서(**Combine**) 문제를 푸는 방법
```python3
def merge_sort(a):
    if len(a) <= 1:    # 리스트가 하나 이하일 경우 (정렬할 필요 없음)
        return a

    mid = len(a) // 2    # 리스트를 반으로 나눔
    left = merge_sort(a[:mid])   # 왼쪽 부분 정렬
    right = merge_sort(a[mid:])  # 오른쪽 부분 정렬

    # 정렬된 두 리스트를 병합
    result = []  # 병합 결과를 담을 리스트 초기화
    i = j = 0    # 각각 left, right 인덱스 초기화

    # 두 리스트를 비교하면서 더 작은 값을 결과에 추가
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])   # result 리스트에 추가
            i += 1
        else:
            result.append(right[j])
            j += 1

    # 남은 값이 있으면 결과에 추가 (둘 중 하나만 남을 수 있음)
    result += left[i:]
    result += right[j:]

    return result

# 테스트
print(merge_sort([5, 3, 8, 4, 2]))
# 출력: [2, 3, 4, 5, 8]
```

### 1-5. 퀵 정렬 (Quick Sort)

피벗(pivot)을 정하고 작은 값/큰 값으로 나눈 뒤 재귀 호출 / 평균 O(n log n), 최악 O(n2)
> 피벗 : 퀵 정렬에서 큰 값과 작은 값을 나누기 위한 기준이 되는 값
> **알맞는 피벗을 정해야 성능이 올라감**
```python3
def quick_sort(a):
    # 리스트 길이가 1 이하이면 정렬 완료
    if len(a) <= 1:
        return a

    pivot = a[0]  # 기준값(피벗)을 첫 번째 값으로 설정

    # 피벗보다 작은 값들
    left = [x for x in a[1:] if x <= pivot]

    # 피벗보다 큰 값들
    right = [x for x in a[1:] if x > pivot]

    # 재귀적으로 정렬해서 하나의 리스트로 합침
    return quick_sort(left) + [pivot] + quick_sort(right)

print(quick_sort([5, 3, 8, 4, 2]))
# 출력: [2, 3, 4, 5, 8]
```

### 1-6. 힙 정렬 (Heap Sort)

힙(완전 이진트리)를 이용하여 최대값 또는 최소값을 추출 / O(n log n)
> 힙 : 완전 이진트리 형태의 자료구조
> 부모 노드와 자식 노드의 크기 관계가 있는 트리
> > ```
    최대 힙 (Max Heap)            최소 힙 (Min Heap)
        9                              1
      /   \                          /   \
        5     6                        3     2
       / \                            / \
      2   3                          5   4
    ```
비교 기반 정렬, 불안정 정렬


