# 정렬

## 목차
1. 정렬의 종류
2. 이진 검색
3. 예제 코드
4. 개인 프로젝트

## 1. 정렬의 종류

### 1-1. 선택 정렬 (Selection Sort)

가장 작은 값을 선택해 맨 앞과 교환 / O(n2)
 
단순하지만 느린 속도
```python3
def selection_sort(a):
    n = len(a)  # 리스트 길이 저장

    for i in range(n):
        min_idx = i  # 현재 위치의 인덱스를 최소값 위치라고 가정

        # 나머지 요소들과 비교해서 더 작은 값이 있으면 위치를 기억함
        for j in range(i+1, n):
            if a[j] < a[min_idx]:
                min_idx = j

        # 가장 작은 값과 현재 위치의 값을 바꿈
        a[i], a[min_idx] = a[min_idx], a[i]

    return a

print(selection_sort([5, 3, 8, 4, 2]))
# 출력: [2, 3, 4, 5, 8]
```

### 1-2. 버블 정렬 (Bubble Sort)

인접한 두 값을 비교하여 큰 값을 뒤로 보냄 / O(n2)

단순하지만 느린 속도
```python3
def bubble_sort(a):
    n = len(a)

    # 리스트를 n번 반복함 (모든 요소가 정렬될 때까지)
    for i in range(n):    # 리스트의 앞에서부터 인접한 값끼리 비교함
        for j in range(0, n - i - 1):    # 뒤쪽은 이미 정렬됐으므로 비교할 범위를 점점 줄임
            if a[j] > a[j + 1]:     # 앞의 값이 뒤의 값보다 크면 자리를 바꿈 (오름차순)
                a[j], a[j + 1] = a[j + 1], a[j]  # 스왑

    return a

print(bubble_sort([5, 3, 8, 4, 2]))
# 출력: [2, 3, 4, 5, 8]
```

### 1-3. 삽입 정렬 (Insertion Sort)

앞에서부터 하나씩 꺼내어 자기 위치에 삽입 / O(n2)

정렬이 어느정도 진행된 데이터에 적용시 빠른 속도
```python3
def insertion_sort(a):
    n = len(a)
    # 1번째 인덱스부터 시작해서 오른쪽으로 이동하면서 정렬
    for i in range(1, n):
        key = a[i]  # 현재 정렬할 값 저장
        j = i - 1     # key보다 앞쪽 요소들의 인덱스

        # 왼쪽 값이 key보다 크면 한 칸 오른쪽으로 이동
        while j >= 0 and a[j] > key:
            a[j + 1] = a[j]  # 큰 값을 오른쪽으로 밀기
            j -= 1

        # key가 들어갈 자리를 찾았으므로 삽입
        a[j + 1] = key

    return a

# 예시
print(insertion_sort([5, 3, 8, 4, 2]))
# 출력: [2, 3, 4, 5, 8]
```

### 1-4. 병합 정렬 (Merge Sort)

리스트를 반으로 나눈 뒤 정렬하여 합침 / O(n log n)

안정 정렬, 분할 정복
> 안정 정렬과 불안정 정렬
> 같은 값을 가진 데이터의 순서를 정렬 한 후 바뀔 수 있는지에 따라 안정 정렬(안바뀜)과 불안정 정렬(바뀜)으로 구분함
> > <img width="562" height="362" alt="image" src="https://github.com/user-attachments/assets/985aa9f1-8f9b-4885-aa07-d852d152511e" />

